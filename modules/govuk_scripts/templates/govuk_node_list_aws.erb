#!/opt/python2.7/bin/python
from __future__ import print_function



# NB: This script uses optparse, not argparse, for Python 2.6 compatibility and
# to avoid the need to depend on any other packages.
from optparse import OptionParser
import json
import random
import string
import sys
import urllib3
import boto3
from urllib.parse import urlencode
from string import Template

### Variables
stackname = '<%= @aws_stackname -%>'
region = '<%= @aws_region -%>'
metadat_path = 'http://169.254.169.254/latest/meta-data/iam/security-credentials/'
http = urllib3.PoolManager()
node_profile = http.request('GET', metadat_path)
credential_template = Template('[default]\naws_access_key_id=$accessId\naws_secret_access_key=$secretKey\naws_session_token=$token')
aws_config = Template('[default]\nregion=$region\noutput=json')
aws_config_path = os.environ['HOME'] + '/.aws/'



## This funcation creates a credentials file based on the metadata profile credentials
## It uses the blue-jumpbox IAM profile in order to identify the node and credentials.
## These credentials are avalible to everyone in the metadata server. The main issue for
## The main reason funcation was a bug boto3 that was causing problems when authenticating. 
def create_creds():
    os.makedirs(aws_config_path)
    request = http.request('GET', metadat_path + 'blue-jumpbox')
    credentials  = json.loads(request.data)
    with open(aws_config_path + 'config', 'w') as f:
        f.write(aws_config.substitute(region=region))
    with open(aws_config_path + 'credentials', 'w') as f:
        f.write(credential_template.substitute(accessId=credentials['AccessKeyId'], secretKey=credentials['SecretAccessKey'],token=credentials['Token']))


def commasep_callback(option, opt, value, parser):
    setattr(parser.values, option.dest, value.split(','))

def ec2_nodes(stackname, nodeclass=None):
    client = boto3.client('ec2', region_name=region)

    if nodeclass:
        response = client.describe_instances(
                   Filters=[
                          {'Name': 'tag:aws_stackname', 'Values': [stackname]},
                          {'Name': 'tag:aws_migration', 'Values': [nodeclass]},
                          {'Name': 'instance-state-name', 'Values': ['running']}
                   ]
               )
    else:
        response = client.describe_instances(
                   Filters=[
                          {'Name': 'tag:aws_stackname', 'Values': [stackname]},
                          {'Name': 'instance-state-name','Values': ['running']}
                   ]
               )

    nodes = response['Reservations']

    hosts = []
    for instance in nodes:
        hosts.append((instance['Instances'][0]['PrivateDnsName']))

    return(hosts)

def ec2_classes(stackname):
    client = boto3.client('ec2', region_name=region)

    response = client.describe_instances(
           Filters=[
              {'Name': 'tag:aws_stackname', 'Values': [stackname]},
              {'Name': 'instance-state-name','Values': ['running']}
           ]
       )

    nodes = response['Reservations']

    classes = []
    for instance in nodes:
        classes.append(filter(lambda t: t['Key'] == 'aws_migration', instance['Instances'][0]['Tags'])[0]['Value'])

    return(sorted(set(classes)))

def get_hostname_by_id(instance_id):
    client = boto3.client('ec2', region_name=region)
    response = client.describe_instances(InstanceIds=[instance_id])
    key = 'PrivateDnsName'
    host = response['Reservations'][0]['Instances'][0]['NetworkInterfaces'][0]
    if not key in host:
        print("The instance attribute {} does not exist".format(key))
        exit(1)
    else:
        return(host[key])

def main():
    opts, args = parser.parse_args()

    if opts.classes:
        classes = ec2_classes(stackname)
        print("\n".join(classes))
        exit(0)

    elif opts.node_class:
        if any('-' in c for c in opts.node_class):
            parser.error('Node classes should not use hyphens. Hint: Try an underscore')

        hosts = []

        for c in opts.node_class:
            hosts.extend(ec2_nodes(stackname, c))

    elif opts.puppet_class:
        endpoint = 'resources'
        host_key = 'certname'

        classes = [string.capwords(c, '::') for c in opts.puppet_class]

        classes = [
            '["=", "title", "{0}"]'.format(c)
            for c in classes
        ]
        class_query = '["or", {0}]'.format(', '.join(classes))
        query = '["and", ["=", "type", "Class"], {0}]'.format(class_query)

        qs = urllib.urlencode({'query': query})
        res = urllib2.urlopen('https://puppetdb.<%= @app_domain_internal %>/v2/{0}?{1}'.format(endpoint, qs))
        instance_ids = json.load(res)

        hosts = []

        for instance in instance_ids:
            hosts.append(get_hostname_by_id(instance[host_key]))

    else:
        hosts = ec2_nodes(stackname)

    if opts.single_node and len(hosts) > 0:
        hosts = [random.choice(hosts)]

    for host in hosts:
        print(host)

parser = OptionParser(description='List nodes in this environment')

parser.add_option(
    '-c', '--node-class',
    '--class',
    dest='node_class',
    type='str',
    help='Restrict the output to nodes of the specified govuk_node_class. (e.g. "frontend,backend")',
    action='callback',
    callback=commasep_callback
)
parser.add_option(
    '-C', '--puppet-class',
    dest='puppet_class',
    type='str',
    help='Restrict the output to nodes of the specified Puppet class. (e.g. "nginx,ssh")',
    action='callback',
    callback=commasep_callback
)

parser.add_option(
    '--single-node',
    help='Select a single node at random',
    action='store_true',
    dest='single_node',
)

parser.add_option(
    '--classes',
    help='List the available classes',
    action='store_true',
    dest='classes',
)

if __name__ == '__main__':
    if not os.path.exists(aws_config_path) and node_profile equal 'blue-jumpbox':
        create_creds()
    main()

